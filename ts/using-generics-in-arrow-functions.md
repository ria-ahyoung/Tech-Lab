# Arrow Functions 에서 올바른 제네릭(`<T>`) 작성 방법


- TypeScript에서 함수의 타입 파라미터(제네릭)를 선언할 때, 함수 파라미터 리스트와 반환 타입 사이에 위치해야 한다.

     - 함수 이름 뒤에 제네릭 타입을 바로 추가하는 것은 해당 함수가 제네릭 타입을 받을 수 있음을 명시하는 것을 의미한다.
     
     - 제네릭 타입은 함수의 파라미터와 반환 타입에 모두 영향을 미치며, 함수를 호출할 때 전달되는 인자의 타입과 반환되는 값의 타입이 제네릭 타입(`<T>`)에 따라 결정되게 된다.

- TypeScript의 화살표 함수에서는 제네릭을 일반 함수와 다르게 작성해야 하는데, 이는 TypeScript 언어 문법의 구조와 제네릭 타입 파라미터의 위치와 관련이 있다.

- 화살표 함수는 일반 함수의 선언 방식처럼 이름 바로 뒤에 `<T>`를 작성하는 것이 문법적으로 허용되지 않기 때문에 쉼표(`,`)나 `extends`를 사용하는 방식을 선택해야 한다.


<br/>

### 문제상황


- 함수 선언식의 문법적인 특징 때문에 function 키워드를 사용하는 일반 함수의 경우 함수 이름 뒤에 제네릭 타입을 바로 추가하는 것이 가능하다.


- arrow functions에서는 제네릭(`<T>`)을 일반 함수처럼 함수 이름 뒤에 작성하지 못하는 이유는 무엇일까?


   - 익명함수로 함수 이름이 없고, 함수 표현식 자체가 파라미터와 반환 타입을 감싸는 구조이기 때문에

   - 함수 이름 뒤에 바로 제네릭을 작성하는 것은 문법적으로 지원되지 않는다.


<br/>


### 올바른 제네릭 사용 방법

- 일반 함수 (with `function` 키워드)
  
  ```tsx
  function GenericsFunc<T>({ /* 함수 파라미터 */ }): T {
    // ...
  }
  ```

- arrow functions

  ```tsx
  const GenericsFunc = <T extends unknown>({ /* 함수 파라미터 */ }): T => {
    ...
  };
  ```

<br/>

**함수 파라미터 리스트와 반환 타입 사이에 제네릭 타입을 위치시키는 이유 :**

- TypeScript에서는 함수의 제네릭 타입이 함수의 입력과 출력에 영향을 미치도록 하기 위해 함수 파라미터 리스트와 반환 타입 사이에 제네릭 타입을 위치시킨다.
- 이렇게 함으로써 제네릭 타입이 함수의 인자와 반환 값의 타입에 따라 동적으로 결정되기 때문에
- 예를 들어, `function identity<T>(arg: T): T { ... }` 같이 작성한 함수는 입력과 출력의 타입을 T라는 제네릭 타입에 따라 다양하게 처리할 수 있다.



**화살표 함수에서 `<T>`로 단독으로 못 쓰는 이유 :**

- 화살표 함수의 문법적인 특성 상, 함수 자체가 파라미터와 반환 타입을 감싸는 구조이기 때문에 함수 이름이 없다.
- 따라서 함수 이름 뒤에 바로 <T>와 같이 제네릭 타입을 작성하는 것은 문법적으로 지원되지 않는다.
- 화살표 함수에서 제네릭 타입을 사용하려면 쉼표(,)를 추가하는 방식이나 extends를 이용하는 방식으로 작성해야 올바른 문법이 된다.


<br/>

### 정리

- 기본적으로 제네릭을 사용하는 목적은 타입 안정성(type safety)을 보장하고 재사용성을 높이는 것으로, 동일한 함수에 여러 종류의 데이터 타입을 주입해 각각의 타입에 맞게 유연하게 동작하도록 하기 위함이다.


- 함수 선언식과 화살표 함수 모두 제네릭 타입을 사용할 수 있지만, 문법적으로 선언 방식에 차이가 있으므로 주의하여 사용해야 한다.
- 함수 선언식은 function 키워드 뒤에 제네릭을 바로 추가할 수 있으며, 화살표 함수에서는 제네릭을 변수 이름 뒤에 추가해야 올바르게 사용할 수 있다.

<br/>


### 추천 레퍼런스
- [Using generics in Arrow functions in TypeScript](https://bobbyhadz.com/blog/typescript-arrow-function-generic)
